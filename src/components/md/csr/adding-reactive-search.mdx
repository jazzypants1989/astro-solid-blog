---
title: "Adding Reactive Search"
slug: "adding-reactive-search"
nextLink: "./conclusion"
---

import Cat from "../../Cat.tsx"

by Jesse Pence

<Cat />

<br />

<iframe
  style="height: fit-content; aspect-ratio: 16/9; width: 100%; border-radius: 10px; shadow: 0 10px 10px 0 rgba(0, 0, 0, 0.2);"
  src="https://www.youtube.com/embed/GOsTR2HrE3A"
  id="ytplayer"
/>

<br />

## **Table of Contents**

<br />

<a href="#introduction">Introduction</a>
<a href="#code">Code</a>
<a href="#conclusion">Conclusion</a>

<br />

## **Introduction**

<br />

Our penultimate chapter will be short and sweet. At this point, I have given you the tools and shown how they can be used. I just want to show you how easy it is to add additional features once you understand these concepts. Let's add a reactive search bar.

<br />

## **Code**

<br />

<div
  style={{
    maxWidth: "100%",
    overflow: "auto",
    borderRadius: "5px",
    fontSize: "1.3rem",
  }}
>
    index.html
    ```js
    <!-- rest of the code -->
    const search = document.querySelector("#search") // Get the search input

    // Our reactive search.

      search.addEventListener("input", searchHandler) // Add an event listener to the search input element we defined with our global variables.

      async function searchHandler() {
        // This is the function that will run every time the user types in that input.
        const searchValue = search.value // Because our search input is a global variable, we can just grab the value from it.
        console.log(`Searching for ${searchValue}`)
        products = await getProducts() // Get the products
        const filteredProducts = products.filter((product) => {
          return product.name.toLowerCase().includes(searchValue.toLowerCase()) // We're converting both the product name and the search value to lowercase so that we can search for "shirt" and "Shirt" and "SHIRT" and "sHiRt" and it will still work.
        })
        if (filteredProducts.length === 0) {
          render(`<h1>Products</h1><p>No products found!</p>`) // A third 404 page! I'm on a roll!
        } else {
          const productsHTML = filteredProducts.map(ProductComponent).join("")
          render(`<h1>Products</h1>${productsHTML}`)
          buttonFinderAdd()
        }
      }
    <!-- rest of the code -->
    ```
</div>

<br />

I can hear you now. "But, wait Jesse! Why did we even learn about URLSearchParams if we didn't need it to make a search bar?" Well, I'm glad you asked. While our app is working perfectly well as it is, what if we wanted to allow people to search for specific things without even opening the app first? I considered two ways of doing this. 

<br />

In the first, we pursue a similar method to the dynamic route by defining the search route in the router function. This works, and almost gives the impression of a nested route, but we end up with a bulky router function filled with else if's. In the second, we allow every route to be a search route and simply check for the search query in the URL on every route. I'll show you both methods.

<br />

<div
  style={{
    maxWidth: "100%",
    overflow: "auto",
    borderRadius: "5px",
    fontSize: "1.3rem",
  }}
  >
    index.html
    ```js
    // rest of the code
    // METHOD ONE (BIG ROUTER)
    const Router = (potentialRoute) => {
        const dynamicRoute = "product" // Define a dynamic route
        const searchRoute = "products" // Define a search route
        const searchParams = new URLSearchParams(location.search) // Get the search params from the URL
        if (
          // DYNAMIC ROUTE LOGIC
          potentialRoute.split("/")[1] === dynamicRoute && // We're turning the path into an array by splitting it every time we see a slash. Then we're checking to see if the second item in the array is the same as the dynamicRoute global variable we set at the top of the file.
          potentialRoute.split("/")[2]
        ) {
          console.log("Dynamic route detected")
          const id = potentialRoute.split("/")[2] // If it is, we're getting the id from the third item in the array. This limits us to only having one dynamic route and only at that point in the array, but we're just showing one way to do it here. This would much more capable and flexible if we were to use regex, but I refuse.
          return ProductPage(id)
        } else if (
          // SEARCH ROUTE LOGIC
          potentialRoute.split("/")[1] === searchRoute &&
          searchParams.has("name")
        ) {
          console.log("Search route detected")
          const searchValue = searchParams.get("name")
          search.value = searchValue
          return searchHandler()
        } else {
          // STATIC ROUTE LOGIC
          console.log("Static route detected")
          const route = Routes.find(
            (route) => route.path === potentialRoute // We're finding the route that matches the path in the address bar.
          )
          route ? route.component() : Nope()
        }
      }

    Router(location.pathname) // We're passing the pathname to the router function.  

    // METHOD TWO (EVERY ROUTE IS A SEARCH ROUTE)

    async function urlSearchHandler() {
        const searchParams = new URLSearchParams(window.location.search) 
        // Create a new URLSearchParams object from the search query in the URL.
        const searchValue = searchParams.get("search") 
        // Get the value of the search query.
        search.value = searchValue 
        // Set the value of the search input to the search query.
        products = await getProducts() 
        // Get the products from the database.

        const filteredProducts = products.filter((product) => {
          return product.name.toLowerCase().includes(searchValue.toLowerCase()) 
          // Filter the products to only include the ones that match the search query.
        })

        if (filteredProducts.length === 0) {
          render(`<h1>Products</h1><p>No products found!</p>`) 
          // If there are no products, Render a message saying so.
        } else {
          const productsHTML = filteredProducts.map(ProductComponent).join("") // If there are products, we're mapping over them and rendering them.
          render(`<h1>Products</h1>${productsHTML}`)
          buttonFinderAdd()
        }
      }

    // We check for search params, then run the urlSearchHandler function if there are any.
      let urlParams = new URLSearchParams(window.location.search)
      if (urlParams.has("search")) {
        urlSearchHandler()
      } else {
        Router(path)
      }

    // rest of the code
    ```
</div>

<br />

To fully demonstrate both of these features, our final code will include them both. With this, we now have three different ways to search for products in our app-- by using the name paramater on the products page, by using the search parameter on any page, and by entering a query into the search input. Some things that I thought about adding to the app were pushing the search query to the URL and allowing the user to search for multiple things at once. But, I already showed you the basics of both of those things in chapter 6. I'll leave it up to you to add those features to the app if you want to.

<br />

## Conclusion

<br />

Our rendering system takes user input and pushes it directly into the HTML. Generally, this is a huge security risk. If users determine that your routing system allows them to directly manipulate your code, they can do some pretty nasty things. For example, they could add a script tag to the URL and run malicious code on your site. This is called a cross-site scripting attack.

<br />

When I first planned this tutorial, I had a whole section dedicated to XSS attacks and other security concerns. But, my most recent designs seem to have made it so that the app is pretty secure. I'm sure there are still some vulnerabilities, and I welcome any insight into things that I have overlooked. 

<br />

Please, don't hack me. Just let me know if there are any vulnerabilities. I keep trying to put script commands into random places and nothing has happened. I'm sure I'm missing something. If you would like to read more about possible XSS vulnerabilities in this kind of system, I recommend Will Taylor's blog article about it listed below.

<br />

[Client Side Routing in Vanilla JS by Will Taylor.](https://www.willtaylor.blog/client-side-routing-in-vanilla-js/)

<br />

Here's the final code with everything put together. Click through to the next chapter for a brief conclusion and another demo of the app.

<br />

<div
style={{
  maxWidth: "100%",
  overflow: "auto",
  borderRadius: "5px",
  fontSize: "1.3rem",
}}
>
https://www.github.com/jazzypants1989/astro-solid-blog/tree/main/src/pages/demos/csr/ch14
</div>
